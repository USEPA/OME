#include "omeobjects/OMEObject.h"
#include "omeobjects/Model.h"

/** Retrieve the full model path name for the object
@return a dot-delimited model path constructed of expression-friendly names
*/
STLString OMEObject::GetFullMdlPathName() const
{
	StrList names;
	for (Model* pCurrMdl = GetParentModel(); pCurrMdl != NULL; pCurrMdl = pCurrMdl->GetParentModel())
		names.push_front(pCurrMdl->GetExprName());

	names.push_back(GetExprName());

	return ConcatStrings(names, '.');
}

/** Copies values from another object.
	All Values are copied except for m_validated and up and down object arrays.
	m_name and m_id are append with underscores to maintain uniqueness (is there a better way to handle this?).
	@param obj the object to be copied.
*/
void OMEObject::Duplicate(const OMEObject & obj)
{
	m_name=obj.m_name;
	m_id=obj.m_id;
	
	m_pParentModel=obj.m_pParentModel;
	//m_unitStr=obj.m_unitStr;
	//m_description=obj.m_description;
	//m_lastModifiedDate=obj.m_lastModifiedDate;
	//m_version=obj.m_version;
	//m_x=obj.m_x;
	//m_y=obj.m_y;
	//m_width=obj.m_width;
	//m_height=obj.m_height;
	m_evalPriority=obj.m_evalPriority;
	m_initPriority=obj.m_initPriority;
    m_isInternal=obj.m_isInternal;
	m_isAutoGenerated = obj.m_isAutoGenerated;

	//m_upObjects, m_downObjects are initialized as blank; we don't want to copy bad relationships
}


//XML stuff
	/** Generates an XML representation of the object.
		A complete node is generated that represents this object.
			@param indent  the number of spaces to place in front of the tag
			@param inc  the number of spaces that should be increased if the depth of indentation is increased
			@return a string containing an xml representation of the object
*/
STLString OMEObject::GetXMLRepresentation(const unsigned int indent, const unsigned int inc)
{
	if (!m_isAutoGenerated)
		return GetXMLForObject(indent,inc);
	return STLString();
}

	/** Generates an XML representation of the object.
		A general function use by children classes. A complete node is generated with a tag id taken from the tag argument.
			@param indent  the number of spaces to place in front of the tag
			@param inc  the number of spaces that should be increased if the depth of indentation is increased
			@return a string containing an xml representation of the object
*/
STLString OMEObject::GetXMLForObject(const unsigned int indent,const unsigned int inc)
{
	STLString tag=GetXMLTag();

	StrArray attrs, subs;
	GetXMLAttributes(attrs);
	GetXMLSubNodes(subs,indent+inc,inc);

   oSTLSStream outStrm; 
	outStrm<<STLString(indent,' ')<<"<"<<tag<<" ";

   for(auto itr=attrs.begin(); itr!=attrs.end(); ++itr)
		outStrm<<(*itr)<<" ";

	if(subs.size())
	{
      outStrm<<">"<<std::endl;

      for(auto itr=subs.begin(); itr!=subs.end(); ++itr)
			outStrm<<(*itr)<<std::endl;

		outStrm<<STLString(indent,' ')<<"</"<<tag<<">";
	}
	else
		outStrm<<"/>";
	return outStrm.str();
}

	/** Generates a list of attributes.
		Generates a list of strings, one for each attribute entry for the top-tier XML tag
			@param out  the array to be populated by attribute strings.

*/
void OMEObject::GetXMLAttributes(StrArray & out) const
{
	AddAttributeValue("id",m_id,out);
	AddAttributeValue("name",m_name,out);

   if(m_isInternal)
     AddAttributeValue("internal",1,out);

	//temp.Format("%i",m_validated);
	//out.Add("validated="+temp);

}

void OMEObject::GetXMLSubNodes(StrArray & out, const unsigned int indent, const unsigned int inc)
{
	//nothing for now
}




void OMEObject::GetXMLAttributeMap(XMLAttrVector & out)
{
	XmlAttr attrs[] = {
      // attr				type		   address                          isReq  checkCol
	  { "id",				XML_STR,	&(this->m_id),					true },
	  { "name",				XML_STR,	&(this->m_name),				false },
     { "internal",      XML_INT,      &(this->m_isInternal),     false },
      { NULL,				XML_NULL,		NULL,							false } };

	  //drop null
	 int count;
	 for(count=0; attrs[count].name!=NULL; count++)
		  out.push_back(attrs[count]);

	  
}

int OMEObject::PopulateFromComplexElements(TI2Element* pCurrElem,const STLString & tag, const STLString & filename)
{
	return 1;
}

const char* OMEObject::ToString(const char tabChar, const unsigned int indent, const unsigned int inc) const
{
	StrArray attrs;
	GetXMLAttributes(attrs);
	oSTLSStream buff;
	buff<<"Address: "<<this<<std::endl;
	buff<<"Type: "<<LabelForType()<<std::endl;
	STLString head(indent,tabChar);

   for(auto itr=attrs.begin(); itr!=attrs.end(); ++itr)
		buff<<head<<(*itr)<<std::endl;

	char* outStr=new char[buff.str().length()+1];
   int i;
	for(i=0; i < buff.str().length(); i++)
		outStr[i]=buff.str()[i];
	outStr[i]='\0';
	return outStr;
}

/** Retrieve an end-user friendly label for a specific object type.
	@param type OMETYPE to retrieve a label for.
	@return Raw C-string containing a user-friendly label for the object type specified for type.
	@sa StrForType.
*/
const OMEChar* OMEObject::LabelForType(OMETYPE type)
{
	switch(type)
	{
	
	case OME_NULL:
		return "No Type";
	case OME_BASE:
		return "Base Object";
	case OME_EVAL:
		return "Evaluable";
	case OME_STATEVAR:
		return "State Variable";
	case OME_VARIABLE:
		return "Variable";
	case OME_VARARRAY:
		return "VarArray";
	case OME_TSVAR: 
		return "Variable (time Series)";
	case OME_FLOW:
		return "Flow";
	case OME_INFLUENCE:
		return "Influence";
	case OME_MODEL:
		return "Model";
	case OME_SUBPORT:
		return "Submodel Port";
	case OME_ASSOCPORT:
		return "Submodel Association Port";
	case OME_SPAWNER:
		return "Spawner";
	case OME_LABEL:
		return "Simple Label";
	case OME_ITERCOND:
		return "Iterator Conditional";
	case OME_SUBASSOC:
		return "Submodel Association";
	case OME_ALIAS:
		return "Alias";
	case OME_CONVEYOR:
		return "Conveyor State Variable";
		break;
	};

	return "";
}

/** Retrieve the source-code friendly name for a specific object type.
@param type OMETYPE to retrieve a label for.
@return Raw C-string containing a source-code friendly name for the object type specified for type.
@sa LabelForType.
*/
const OMEChar* OMEObject::StrForType(OMETYPE type)
{
	switch(type)
	{
	case OME_NULL:
		return "OMENULL";
	case OME_BASE:
		return "OMEObject";
	case OME_EVAL:
		return "Evaluable";
	case OME_STATEVAR:
		return "StateVar";
	case OME_VARIABLE:
		return "Variable";
	case OME_VARARRAY:
		return "VarArray";
	case OME_TSVAR: 
		return "TimeSeriesVar";
	case OME_FLOW:
		return "Flow";
	case OME_INFLUENCE:
		return "Influence";
	case OME_MODEL:
		return "Model";
	case OME_SUBPORT:
		return "SubmodelPort";
	case OME_ASSOCPORT:
		return "AssocPort";
	case OME_SPAWNER:
		return "Spawner";
	case OME_LABEL:
		return "SimpleLabel";
	case OME_ITERCOND:
		return "IterConditional";
	case OME_SUBASSOC:
		return "SubmodelAssoc";
	case OME_ALIAS:
		return "EvalAlias";
	case OME_CONVEYOR:
		return "Conveyor";
	};

	return "";
}
/** Function for looking up labels for OMETYPEs.
	@return raw string with label of type;
	@sa StrForType
*/
const OMEChar* OMEObject::LabelForType() const
{
	return LabelForType(GetOMEType());
}

/** Function for looking up labels for OMETYPEs.
@return raw string with String name of type;
@sa LabelForType
*/
const OMEChar* OMEObject::StrForType() const
{
	return StrForType(GetOMEType());
}

/** Determine the relative processing priority for this object. 
	@param currPriority The current priority level being processed.
	@param isInitial Flag that indicates whether or not the prioritization is
			for an initialization step. Some objects prioritize differently 
			during the initialization process than they do during normal running
			operations.
	@return The priority of the object (it may be higher than currPriority based
			on previous processing).
*/
unsigned int OMEObject::Prioritize(unsigned int currPriority, const bool isInitial) 
{ 

	unsigned int* pCompPriority = isInitial ? &m_initPriority : &m_evalPriority;
	if(*pCompPriority>m_evalPriority)
		*pCompPriority=currPriority; 
	return *pCompPriority;
}

void OMEObject::EventAction(const CentralEvent & ev, void* extra)
{
	//nothing for now
	STLString type=ev.GetEventType();
	//if(type=="OME_UPDATE_DESCRIPTION")
	//	m_description=CString(*(CString*)ev.GetPayload());

	//additional responders below
}

/** Equivalence operator.
	@param obj The object to compare against.
	@return true if the objects contain equivalent values; false otherwise.
*/
bool OMEObject::operator==(const OMEObject & obj)
{
	return this==&obj ||
		(
		m_id==obj.m_id &&
		m_evalPriority==obj.m_evalPriority &&
		m_initPriority==obj.m_initPriority &&
		m_isInternal==obj.m_isInternal &&
		m_name==obj.m_name
		);
}

