#include "CompiledMdlFuncs.h"
#include "CPPLoopCluster.h"

using namespace OMECFuncs;

RAN_ENGINE sGen((unsigned int)SEED);
const unsigned int IND_CACHE_SIZE = 64;
size_t s_oldIndCache[IND_CACHE_SIZE];



/** Generate statements for the makeArray() expression function.
	@param outBuff The string buffer to write to.
	@param pCaller Pointer to the Evaluable object containing call.
	@param pSrc Pointer to the CPPLoopCluster containing the entry for pCaller.
	@param clustInd The index of pSrc in its parent CPPLoopCluster.
	@param call The invocation of makeArray().
	@param inInit If true, initialization statements are being requested; otherwise, update statements are being requested.
	@return A value representing the type of value that will be generated by the implemented makeArray() code.
*/
FuncSig::FS_ARGS OMECFuncs::GenMakeArray(const STLString & className, oSTLSStream & outBuff, Evaluable* pCaller, CPPLoopCluster* pSrc, size_t & clustInd, const STLString & call, const bool & inInit)
{
	//recursively tease out dims and final assignment
	STLRegex maReg("\\s*makearray[(](.*),\\s*([0-9.]+?)\\s*[)]");
	STLRegex piReg("place_in[(]([0-9]+)[)]");
	STLsmatch mtch;

	VarArray* pVa = dynamic_cast<VarArray*>(pCaller);
	if (!pVa)
		throw OMEFuncOpException("GenMakeArray","makearray() can only be applied to VarArray model components.");
	STLString expr = call;

	size_t count = 0;
	while (std::regex_search(expr, mtch, maReg))
	{
		++count;
		if (inInit && pVa->GetDimCount() < count)
		{
			//add dims if necessary
			pVa->AddDimFront(std::stoi(mtch[2].str()));
		}
		expr = mtch[1].str();
	}

	//at this point, expr should be what assigns value to each slot
	//check if expr is constant; if it is, assignment only needs to occur during init.
	STLRegex numReg("^\\s*[-+]?\\s*[0-9]+(?:[.][0-9]*)?\\s*$");
	Model* pMdl = pVa->GetParentModel();
	pVa->SetIsConstant((!pMdl || !pMdl->IsDynamic()) && (expr.empty() || std::regex_match(expr, numReg)));

	if (inInit || !pVa->GetIsConstant())
	{
		//add loops for update
		STLString lbl = "makeArray_" + pCaller->GetID();
		size_t insertInd = clustInd;
		CPPLoopCluster* pParent = pSrc;
		StrList dimStr;
		for (size_t i = 0; i < pVa->GetDimCount(); ++i)
		{
			dimStr.push_back(std::to_string(pVa->GetDim(i)));
			pParent = pParent->NewSubLoopCluster(insertInd, pVa->GetDim(i), lbl + std::to_string(i + 1));
			pParent->GetParentEntry()->AddAssigned(pCaller->GetID());
			insertInd = 0;
		}

		pSrc->GetRootCluster()->AddInitializationStatement(pCaller->GetID() + ".OverrideDims({" + ConcatStrings(dimStr, ',') + "});\n" + pCaller->GetID() + ".Allocate();");
		;
		FuncSig::FS_ARGS rType;
		unsigned short ld;
		size_t subInd = 0;

		//process place_in calls here as well
		expr = std::regex_replace(pParent->CPPizeExpression(expr, pCaller, inInit, subInd), piReg, lbl + "$1" + "_i+1");

		//copy pSrc into innermost loop with new updatestatement. (use TmpDeclaration to avoid reparsing Eval)
		pParent->AppendCustomEntry(expr, pCaller->GetID() + "_ma", pCaller->GetID());

		//nothing needs to be added to outbuff; add loops will take care of that
		++clustInd;
	}
	return FuncSig::LIST_ARG;
}

/** Generate statements for the element() expression function.
@param outBuff The string buffer to write to.
@param pCaller Pointer to the Evaluable object containing call.
@param pSrc Pointer to the CPPLoopCluster containing the entry for pCaller.
@param clustInd The index of pSrc in its parent CPPLoopCluster.
@param call The invocation of element().
@param inInit If true, initialization statements are being requested; otherwise, update statements are being requested.
@return A value representing the type of value that will be generated by the implemented element() code.
*/
FuncSig::FS_ARGS OMECFuncs::GenElement(const STLString & className, oSTLSStream & outBuff, Evaluable* pCaller, CPPLoopCluster* pSrc, size_t & clustInd, const STLString & call, const bool & inInit)
{
	
	

	StrList args,dummies;

	FSArgList retTypes;
	FuncSig::FS_ARGS outType=FuncSig::NO_ARGS,dummyRet;
	unsigned short listDepth=0;
	size_t argPos = call.find('(');
	VarArray* pVa = NULL;
	Evaluable* pArg;
	STLRegex lenReg("(?:[#][0-9]+)+$");
	size_t chompPos;
	STLsmatch mtch,mtch2;
	//pSrc->ProcessFuncArgs(call.substr(argPos + 1, FindMatching(call, argPos, '(', ')') - argPos - 1), args, retTypes, pCaller, listDepth, inInit, clustInd);
	pSrc->FindFuncArgs(call.substr(argPos + 1, FindMatching(call, argPos, '(', ')') - argPos - 1), args);

	//process all subArgs
	for (STLString & a : args)
	{
		FuncSig::FS_ARGS currRet=FuncSig::NO_ARGS;
		a = pSrc->CPPizeExpression(a, pCaller, inInit, clustInd, true,&currRet);
		retTypes.push_back(currRet);
	}
	bool calledOnSIV = false;
	size_t depth;
	if(args.front().substr(0, 7) == "element")
	{
		calledOnSIV = true;
		//nested arg; will be receiving SIV,so depth is not needed
	}
	oSTLSStream assignBuff;

	if (retTypes.size() == 2)
	{
		//DBG_PRINTC(ConcatStrings(args, '\n'), DBG_GREEN);

		std::regex_search(args.front(), mtch, lenReg);
		depth = CountChar(mtch[0].str(), '#');

		if (retTypes.back()!=FuncSig::LIST_ARG)
		{
			STLString rawName = args.front().substr(0, args.front().find('#'));
			outType = FuncSig::SCLR_ARG;
			OMEObject* pObj = pCaller->GetParentModel()->GetRootModel()->ObjectForKey(rawName);

			if (calledOnSIV)
			{
				outBuff << "element(" << rawName << ',' << args.back() << ")"<<mtch[0].str().substr(0,mtch[0].str().rfind('#'));
			}
			else
			{
				//make sure that list is properly processed
				//if any operators are present, we need to sub the list out
				STLRegex opReg("[-+><=/*%]");
				STLsmatch opMtch;
				if (std::regex_search(args.front(), opMtch, opReg))
				{
					STLsmatch extMtch;
					STLString ext;
					if (std::regex_search(args.front(), extMtch, STLRegex("([a-zA-Z_][0-9a-zA-Z_]*)((?:[#][0-9]+)+)")))
						ext = extMtch[2].str();
					STLString tmpName = CPPLoopCluster::GenVarName("tmp_lst",pSrc->GetParentEntry());
					pSrc->NewTempDeclaration(clustInd++, "OME_SCALAR " + tmpName + "[@xi]={};", tmpName);
					pSrc->NewTempApplication(clustInd++, tmpName + ext+"=" + args.front() + ";", tmpName);
					rawName = tmpName;
					pObj = NULL;
				}

				if (pObj) //evaluable of some sort
				{
					outBuff << "element";
					//figure out if model is in heirarchy
					Model* pTrgMdl = pCaller->GetParentModel();
					//try for common model in one direction.
					for (; pTrgMdl && pTrgMdl != pObj->GetParentModel(); pTrgMdl = pTrgMdl->GetParentModel());
					//if that fails, try common model in other direction
					if (!pTrgMdl)
					{
						pTrgMdl = pObj->GetParentModel();
						for (; pTrgMdl && pTrgMdl != pCaller->GetParentModel(); pTrgMdl = pTrgMdl->GetParentModel());
					}

					if (!pTrgMdl)
						outBuff << "Raw";
					outBuff<< "(" << rawName << ',' << args.back() << ',' << depth << ")" << mtch[0].str().substr(0, mtch[0].str().rfind('#'));

				}
				else
				{
					//simpleArray
					outBuff << "element((OME_SCALAR*)" << rawName << ',' << rawName<<"_dims" << ',' << args.back() << ',' << (depth ? depth : 1) << ")"<< mtch[0].str().substr(0, mtch[0].str().rfind('#'));
				}

				CPPLoopCluster::AddDimReference(outBuff.str(), rawName + mtch[0].str().substr(0, mtch[0].str().rfind('#')));
			}
		}
		else
		{
				//list from list
			std::regex_search(args.back(), mtch2, lenReg);
				size_t tmpLen = std::stoul(mtch2[0].str().substr(mtch2[0].str().rfind('#') + 1));
				if (!tmpLen)
				{
					//try to derive from outermost dim of model object
					VarArray* pVa=dynamic_cast<VarArray*>(pCaller->GetParentModel()->GetRootModel()->ObjectForKey(args.back().substr(0, args.back().find('#'))));
					tmpLen=pVa->GetDim(pVa->GetDimCount() - 1);
				}
				STLString tmpName = CPPLoopCluster::GenVarName("tmp_listGen",pSrc->GetParentEntry());
				pSrc->NewTempDeclaration(clustInd++, "OME_SCALAR " + tmpName + "[" + std::to_string(tmpLen) + "]={};",tmpName,STLString(),tmpLen);
				outBuff << tmpName << "#" << tmpLen;
				for (size_t i = 0; i < tmpLen; ++i)
				{
					assignBuff << tmpName << '[' << i << "]=" << args.front().substr(0, args.front().find('#')) << '[' << args.back().substr(0, args.back().find('#')) << '[' << i << "]-1];" << endl;
				}
				pSrc->NewCustomEntry(clustInd++, assignBuff.str(), args.back(),tmpName);

		}
	}
	//else err
		return outType;
}

/** Generate statements for the count() expression function.
@param outBuff The string buffer to write to.
@param pCaller Pointer to the Evaluable object containing call.
@param pSrc Pointer to the CPPLoopCluster containing the entry for pCaller.
@param clustInd The index of pSrc in its parent CPPLoopCluster.
@param call The invocation of count().
@param inInit If true, initialization statements are being requested; otherwise, update statements are being requested.
@return A value representing the type of value that will be generated by the implemented count() code.
*/
FuncSig::FS_ARGS OMECFuncs::GenCount(const STLString & className, oSTLSStream & outBuff, Evaluable* pCaller, CPPLoopCluster* pSrc, size_t & clustInd, const STLString & call, const bool & inInit)
{
	FuncSig::FS_ARGS retType;
	size_t argPos = call.find('(');
	STLString body=pSrc->CPPizeExpression(call.substr(argPos + 1, FindMatching(call, argPos, '(', ')') - argPos - 1), pCaller, inInit, clustInd, true, &retType);
	STLString rawName = body.substr(0, body.find('#'));
	unsigned int depth = CountChar(body, '#');
	
	OMEObject* pObj = pCaller->GetParentModel()->GetRootModel()->ObjectForKey(rawName);

	if (pObj)
	{
		Model* pMdl,*pNextMdl;
		VarArray* pVa = dynamic_cast<VarArray*>(pObj);

		if (pVa)
		{
			if (depth < pVa->GetDimCount())
				outBuff << pVa->GetDim(pVa->GetDimCount() - 1 - depth);
			depth = 0;
		}

		if (depth)
		{
			pNextMdl = pObj->GetParentModel();
			unsigned int i = 0;
			do
			{
				pMdl = pNextMdl;
				if (!pMdl->IsDynamic() && pMdl->GetInitNumInstances() != 1)
					++i;
				pNextMdl = pMdl->GetParentModel();
			} while (i < depth);
			

			outBuff << pMdl->GetID()<<".GetNumInstances()";
		}
		
	}
	else
	{
		//simpleArray
		outBuff << "sizeof(" << rawName << ")/sizeof(OME_SCALAR)";

	}
	return FuncSig::FS_ARGS::SCLR_ARG;
}

FuncSig::FS_ARGS OMECFuncs::GenIndex(const STLString & className, oSTLSStream & outBuff, Evaluable* pCaller, CPPLoopCluster* pSrc, size_t & clustInd, const STLString & call, const bool & inInit)
{
	size_t argPos = call.find('(');
	size_t endPos = FindMatching(call, argPos, '(', ')');
	++argPos;
	--endPos;
	unsigned int count=(unsigned int)OME_SCLR_READSTR(call.substr(argPos, endPos - argPos));

	//Model* pMdl = pCaller->GetParentModel();
	//for (unsigned i = 1; i < count; ++i)
	//	pMdl = pMdl->GetParentModel();

	outBuff << "@i" << count << "+1";

	return FuncSig::FS_ARGS::SCLR_ARG;
}

FuncSig::FS_ARGS OMECFuncs::GenInitOnly(const STLString & className, oSTLSStream & outBuff, Evaluable* pCaller, CPPLoopCluster* pSrc, size_t & clustInd, const STLString & call, const bool & inInit)
{
	if (inInit)
	{
		FuncSig::FS_ARGS retType;
		size_t argPos = call.find('(');
		size_t endPos = FindMatching(call, argPos, '(', ')');
		++argPos;
		--endPos;
		outBuff << pSrc->CPPizeExpression(call.substr(argPos, endPos - argPos + 1), pCaller, inInit, clustInd, true, &retType);
		return FuncSig::FS_ARGS::SCLR_ARG;
	}
	return FuncSig::NO_ARGS;
	
}

FuncSig::FS_ARGS OMECFuncs::GenValuesFromInstances(const STLString & className, oSTLSStream & outBuff, Evaluable* pCaller, CPPLoopCluster* pSrc, size_t & clustInd, const STLString & call, const bool & inInit)
{
	StrList argList;
	StrArray args;
	unsigned short listDepth = 0;
	size_t argPos = call.find('(');
	VarArray* pVa = NULL;
	Evaluable* pArg;
	STLRegex lenReg("(?:[#][0-9]+)+$");
	size_t chompPos;
	STLsmatch mtch;
	//pSrc->ProcessFuncArgs(call.substr(argPos + 1, FindMatching(call, argPos, '(', ')') - argPos - 1), args, retTypes, pCaller, listDepth, inInit, clustInd);
	pSrc->FindFuncArgs(call.substr(argPos + 1, FindMatching(call, argPos, '(', ')') - argPos - 1), argList);
	for (STLString & a : argList)
	{
		a = pSrc->CPPizeExpression(a, pCaller, inInit, clustInd, true);
		args.push_back(a);
	}

	//find any array flags
	std::regex_match(call, mtch, lenReg);

	//arg 0 is eval
	//arg 1 is list

	//arg 2 will be our list.
	//arg 3 will be length of arg 1;

	
	//outBuff is the variable name
	STLString outName = CPPLoopCluster::GenVarName("vfi_array",pSrc->GetParentEntry());

	
	outBuff << outName << mtch[0].str()<<"#0";

	STLString trgList = args[1].substr(0, args[1].find("#"));

	STLString limit = "sizeof(" + outName + ")/sizeof(OME_SCALAR) && " + outName + "[@ii]!=OME_NOVAL";
	oSTLSStream vfiBuff;
	CPPLCSubEntry* pDecl = pSrc->NewTempDeclaration(clustInd++, "OME_SCALAR " + outName + "[" + "sizeof(" + trgList + ") / sizeof(size_t)" + "]={};", outName);
	pDecl->SetLoopLimitCheck(limit);
	vfiBuff << "valuesFromInstances("<< args[0] << "," << trgList << "," << outName << ",sizeof(" << trgList << ")/sizeof(size_t));" << endl;
	CPPLCSubEntry* pEnt=pSrc->NewCustomEntry(clustInd++, vfiBuff.str(), outName,outName);
	pEnt->SetLoopLimitCheck(limit);

	return FuncSig::FS_ARGS::LIST_ARG;
}

FuncSig::FS_ARGS OMECFuncs::GenSDPNextToID(const STLString & className, oSTLSStream & outBuff, Evaluable* pCaller, CPPLoopCluster* pSrc, size_t & clustInd, const STLString & call, const bool & inInit)
{
	StrList argList;
	StrArray args;
	unsigned short listDepth = 0;
	size_t argPos = call.find('(');
	VarArray* pVa = NULL;
	Evaluable* pArg;
	STLRegex lenReg("(?:[#][0-9]+)+$");
	size_t chompPos;
	STLsmatch mtch;
	//pSrc->ProcessFuncArgs(call.substr(argPos + 1, FindMatching(call, argPos, '(', ')') - argPos - 1), args, retTypes, pCaller, listDepth, inInit, clustInd);
	pSrc->FindFuncArgs(call.substr(argPos + 1, FindMatching(call, argPos, '(', ')') - argPos - 1), argList);
	for (STLString & a : argList)
	{
		a = pSrc->CPPizeExpression(a, pCaller, inInit, clustInd, true);
		args.push_back(a);
	}

	//find any array flags
	std::regex_match(call, mtch, lenReg);

	//arg 0 is eval
	//arg 1 is list

	//arg 2 will be our list.
	//arg 3 will be length of arg 1;


	//outBuff is the variable name
	STLString outName = CPPLoopCluster::GenVarName("sdpnti_array",pSrc->GetParentEntry());


	outBuff << outName << mtch[0].str()<<"#0";

	oSTLSStream sdpBuff;
	STLString limit = "OME_MAX_NEIGHBORS && " + outName + "[@ii]!=0";
	CPPLCSubEntry* pDecl = pSrc->NewTempDeclaration(clustInd++, "size_t " + outName + "[OME_MAX_NEIGHBORS]={};", outName);
	pDecl->SetLoopLimitCheck(limit);
	sdpBuff<<"SDPNextToID(" <<className<<"SDP,"<< args[0] << "," << outName << ");" << endl;
	CPPLCSubEntry* pEnt = pSrc->NewCustomEntry(clustInd++, sdpBuff.str(), outName,outName);
	pEnt->SetLoopLimitCheck(limit);

	return FuncSig::FS_ARGS::LIST_ARG;
}

void OMECFuncs::LoadSigs(std::map<STLString,FuncSig> & sigs)
{
    //custom arg funcs
    auto SclrOnlyFunc =    [](const FuncSig::FSA_TYPE & inVal,const unsigned int & listDepth)   ->FuncSig::FS_ARGS{ return FuncSig::SCLR_ARG; };
    auto IntOnlyFunc =     [](const FuncSig::FSA_TYPE & inVal,const unsigned int & listDepth)    ->FuncSig::FS_ARGS{ return FuncSig::INT_ARG; };
    auto ListOnlyFunc =    [](const FuncSig::FSA_TYPE & inVal,const unsigned int & listDepth)   ->FuncSig::FS_ARGS{ return FuncSig::LIST_ARG; };
    auto StrOnlyFunc =     [](const FuncSig::FSA_TYPE & inVal,const unsigned int & listDepth)    ->FuncSig::FS_ARGS{ return FuncSig::STR_ARG; };
    auto MultiArgFunc =    [](const FuncSig::FSA_TYPE & inVal,const unsigned int & listDepth)   ->FuncSig::FS_ARGS{ return inVal & FuncSig::LIST_ARG ? FuncSig::LIST_ARG : FuncSig::SCLR_ARG; };
    auto MultiIntArgFunc = [](const FuncSig::FSA_TYPE & inVal,const unsigned int & listDepth)->FuncSig::FS_ARGS{ return inVal & FuncSig::LIST_ARG ? FuncSig::LIST_ARG : FuncSig::INT_ARG; };
    auto MultiVAArgFunc =  [](const FuncSig::FSA_TYPE & inVal,const unsigned int & listDepth) ->FuncSig::FS_ARGS{ return inVal & FuncSig::VA_ARG ? FuncSig::LIST_ARG : FuncSig::SCLR_ARG; };
    auto MultiDefArgFunc = [](const FuncSig::FSA_TYPE & inVal,const unsigned int & listDepth)->FuncSig::FS_ARGS{ return inVal & FuncSig::EVAL_ARG ? FuncSig::SCLR_ARG : (FuncSig::FS_ARGS)inVal; };
    auto ElemArgFunc =     [](const FuncSig::FSA_TYPE & inVal, const unsigned int & listDepth)->FuncSig::FS_ARGS{ return listDepth<=1 && inVal!=FuncSig::LIST_ARG ? FuncSig::ALIAS_ARG : FuncSig::LIST_ARG; };
    auto SclrVariantArgFunc = [](const FuncSig::FSA_TYPE & inVal, const unsigned int & listDepth)->FuncSig::FS_ARGS{ return listDepth <= 1 && inVal ? FuncSig::SCLR_ARG : FuncSig::LIST_ARG; };
    auto IntVariantArgFunc = [](const FuncSig::FSA_TYPE & inVal, const unsigned int & listDepth)->FuncSig::FS_ARGS{ return listDepth <= 1 && inVal ? FuncSig::INT_ARG : FuncSig::LIST_ARG; };
    
    
    //entries
    sigs["abs"] = FuncSig::MultiFuncSig("OMECFuncs::abs", "@SI", "@SO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["acos"] = FuncSig::MultiFuncSig("OMECFuncs::acos", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["asin"] = FuncSig::MultiFuncSig("OMECFuncs::asin", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["at_init"] = FuncSig::MultiFuncSig("at_init", "@EI", "@sO");
    sigs["atan"] = FuncSig::MultiFuncSig("OMECFuncs::atan", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["atan2"] = FuncSig::MultiFuncSig("OMECFuncs::atan2", "@SI,@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
	
	sigs["beta_ran"] = FuncSig("beta_ran", "@SI,@SI,@S?,@S?,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["binome"] = FuncSig("binome", "@SI,@SI,@S?,@S?,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["exponent_ran"] = FuncSig("exponent_ran", "@S?,@S?,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["gamma_ran"] = FuncSig("gamma_ran", "@SI,@SI,@S?,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["negBinomial_ran"] = FuncSig("negBinomial_ran", "@SI,@SI,@S?,@S?,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["poidev"] = FuncSig("poidev", "@SI,@S?,@S?,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["gaussian_var"] = FuncSig("gaussian_var", "@SI,@S?,@SI,@SI,@SI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["triangle_ran"] = FuncSig("triangle_ran", "@SI,@SI,@SI,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["weib_ran"] = FuncSig("weib_ran", "@SI,@SI,@S?,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);

    sigs["ceil"] = FuncSig::MultiFuncSig("ceil", "@SI", "@SO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["channel_is"]=FuncSig("channel_is","@EC,@SP","@bO",FuncSig::NO_FLAGS,IntOnlyFunc);
    sigs["const_delay"] = FuncSig("const_delay", "@EI,@SI", "@sO", FuncSig::PAST_LOOKUP,SclrOnlyFunc);
    sigs["cos"] = FuncSig::MultiFuncSig("OMECFuncs::cos", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["cosh"] = FuncSig::MultiFuncSig("OMECFuncs::cosh", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["dies_of"] = FuncSig::MultiFuncSig("dies_of", "@EC,@SP", "@bO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["dt"] = FuncSig::MultiFuncSig("dt", "@CI,@S?", "@sO", FuncSig::NO_FLAGS, MultiArgFunc);
	sigs["end_time"] = FuncSig("end_time", "@BM", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["exp"] = FuncSig::MultiFuncSig("OMECFuncs::exp", ",@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["factorial"]=FuncSig::MultiFuncSig("factorial","@SI","@sO");
    sigs["first"] = FuncSig::MultiFuncSig("first", "@NI", "@bO", FuncSig::NO_FLAGS, IntOnlyFunc);
    sigs["floor"] = FuncSig::MultiFuncSig("floor", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["fmod"] = FuncSig("::fmod", "@SI,@SI", "@sO");
    sigs["following"]=FuncSig::MultiFuncSig("following","@NI","@NO");
    sigs["gaussian_var"]=FuncSig("gaussian_var","@SI,@SI,@S?,@S?","@sO");
    sigs["graph"] = FuncSig("interpTable", "@CI,@BM,@SI,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["hypergeom"]=FuncSig("hypergeom","@SI,@SI,@SI","@iO", FuncSig::NO_FLAGS, IntOnlyFunc);
    sigs["hypot"]=FuncSig("hypot","@SI,@SI","@sO");
    sigs["init_time"] = FuncSig::MultiFuncSig("init_time", "@CI", "@sO", FuncSig::NO_FLAGS, MultiArgFunc);
    sigs["in_preceding"]=FuncSig::MultiFuncSig("in_preceding","@CI,@TI","@MO");
    sigs["in_progenitor"]=FuncSig::MultiFuncSig("in_progenitor","@CI,@TI","@MO");
    sigs["index"] = FuncSig::CustomFuncSig("index", GenIndex, FuncSig::NO_FLAGS, MultiArgFunc);
    sigs["inf"] = FuncSig("OME_SCALAR_INF", "@NI", "@sO");
	sigs["initOnly"] = FuncSig::CustomFuncSig("initOnly", GenInitOnly, FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["int"] = FuncSig::MultiFuncSig("toInt", "@SI", "@sO");
    sigs["interpTable"] = FuncSig("interpTable", "@CI,@BM,@SI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["last"] = FuncSig::MultiFuncSig("last", "@BM,@EI", "@?OsL", FuncSig::PAST_LOOKUP, SclrOnlyFunc);
    sigs["log"] = FuncSig::MultiFuncSig("OMECFuncs::log", "@SI,@S?", "@sO");
    sigs["log10"] = FuncSig::MultiFuncSig("OMECFuncs::log10", "@SI", "@sO");
    sigs["max"] = FuncSig("OMEMax", "@SI,@SI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["min"] = FuncSig("OMEMin", "@SI,@SI", "@sO",FuncSig::NO_FLAGS,SclrOnlyFunc);
    sigs["parent"] = FuncSig("parent", "@CI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["poidev"] = FuncSig("poidev", "@SI", "@sO");
    sigs["pow"] = FuncSig("OMECFuncs::pow", "@SI,@SI", "@sO", FuncSig::NO_FLAGS, MultiArgFunc);
    sigs["preceding"]=FuncSig::MultiFuncSig("preceding","@NI","NO");
    sigs["prev"] = FuncSig("prev", "@CI,@SI", "@sO", FuncSig::PAST_LOOKUP,MultiVAArgFunc);
    sigs["pulse"] = FuncSig("pulse", "@SI,@SI,@S?,@BM", "@sO");
    sigs["ramp"] = FuncSig("ramp", "@SI,@SI,@BM", "@sO");
    sigs["rand_var"] = FuncSig("rand_var", "@SI,@SI", "@sO");
    sigs["rand_const"] = FuncSig("rand_const", "@SI,@SI", "@sO");
    sigs["round"] = FuncSig::MultiFuncSig("round", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["self"] = FuncSig("@CI", "", "@EO");
    sigs["sgn"] = FuncSig::MultiFuncSig("sgn", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["sin"] = FuncSig::MultiFuncSig("OMECFuncs::sin", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["sinh"] = FuncSig::MultiFuncSig("OMECFuncs::sinh", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["sqrt"] = FuncSig::MultiFuncSig("OMECFuncs::sqrt", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
	sigs["step"] = FuncSig("step", "@SI,@SI,@BM", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["stop"] = FuncSig("stop", "@SI,@BM", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["table"] = FuncSig("table", "@CI,@BM,@SI,@S?,@S?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["tan"] = FuncSig::MultiFuncSig("OMECFuncs::tan", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["tanh"] = FuncSig::MultiFuncSig("OMECFuncs::tanh", "@SI", "@sO", FuncSig::NO_ARGS, MultiArgFunc);
    sigs["time"] = FuncSig("currenttime", "@BM,@s?", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["var_delay"] = FuncSig("var_delay", "@EI,@SI", "@sO", FuncSig::PAST_LOOKUP, SclrOnlyFunc);
	sigs["var_delay_withInit"] = FuncSig("var_delay_withInit", "@BM,@CI,@EI,@SI,@SI", "@sO", FuncSig::PAST_LOOKUP, SclrOnlyFunc);
    sigs["all"] = FuncSig("all", "@LI", "@?OsL",FuncSig::LOCAL_ACCUM, IntVariantArgFunc);
    sigs["any"] = FuncSig("any", "@LI", "@?OsL", FuncSig::LOCAL_ACCUM, IntVariantArgFunc);
    sigs["colin"] = FuncSig("colin", "@LI", "@uO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["count"] = FuncSig::CustomFuncSig("count", GenCount, FuncSig::NO_FLAGS, IntOnlyFunc);
    sigs["element"] = FuncSig::CustomFuncSig("element", GenElement, FuncSig::NO_FLAGS, ElemArgFunc);
    sigs["firsttrue"] = FuncSig("firsttrue", "@S?", "@?OsL", FuncSig::LOCAL_ACCUM, SclrVariantArgFunc);
    sigs["greatest"]=FuncSig("greatest","@LI","@?OsL",FuncSig::LOCAL_ACCUM);
    sigs["howmanytrue"] = FuncSig("howmanytrue", "@LI", "@sO", FuncSig::LOCAL_ACCUM, SclrOnlyFunc);// FuncSig::LOCAL_ACCUM ?
    sigs["least"]=FuncSig("least","@LI","@?OsL",FuncSig::LOCAL_ACCUM);
    sigs["makearray"] = FuncSig::CustomFuncSig("makearray", GenMakeArray, FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["place_in"] = FuncSig("place_in", "@SI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["posgreatest"] = FuncSig("posgreatest", "@LI", "@sO", FuncSig::LOCAL_ACCUM, IntOnlyFunc);
    sigs["posleast"] = FuncSig("posleast", "@LI", "@sO", FuncSig::LOCAL_ACCUM, IntOnlyFunc);
    sigs["product"] = FuncSig("product", "@LI", "@?OsL", FuncSig::LOCAL_ACCUM, SclrVariantArgFunc);
    sigs["rankings"]=FuncSig::MultiRetSig("rankings","@LI","@LO");
    sigs["size"] = FuncSig("size", "@MI,@SI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["subtotals"] = FuncSig::MultiRetSig("subtotals", "@LI", "@LO", FuncSig::LOCAL_ACCUM);	//  FuncSig::LOCAL_ACCUM ?
    sigs["sum"] = FuncSig("sum", "@LI", "@?OsL", FuncSig::LOCAL_ACCUM, SclrVariantArgFunc);
    sigs["with_colin"] = FuncSig("with_colin", "@LI,@LI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["with_greatest"] = FuncSig("with_greatest", "@LI,@LI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["with_least"] = FuncSig("with_least", "@LI,@LI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["default"] = FuncSig("OMEdefault", "@SI", "@sO", FuncSig::NO_FLAGS, MultiDefArgFunc);
    sigs["for_members_of_type"] = FuncSig::MultiRetSig("for_members_of_type", "@SI,@LI", "@LO", FuncSig::NO_FLAGS, ListOnlyFunc);
    sigs["interpolate"] = FuncSig("interpolate", "@SI,@LI,@LI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc); //  FuncSig::LOCAL_ACCUM ?
    sigs["iterations"] = FuncSig("iterations", "@II", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["ordinals"] = FuncSig::MultiRetSig("ordinals", "@XI", "@LO", FuncSig::NO_FLAGS, ListOnlyFunc);
    sigs["pi"] = FuncSig("3.141592653589793238462", "@NI", "@sO");
    sigs["product3"] = FuncSig("product3", "@MI,@MI", "@aO", FuncSig::NO_FLAGS, ListOnlyFunc);
    sigs["transform3"] = FuncSig("transform3", "@MI,@VI", "@aO", FuncSig::NO_FLAGS, ListOnlyFunc);
	//valueFromInstance(const Evaluable& eval, size_t inInd, const size_t & lim)
	sigs["valueFromInstance"] = FuncSig("valueFromInstance", "@EI,@SI","@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["valuesFromInstances"] = FuncSig::CustomFuncSig("valuesFromInstances", GenValuesFromInstances, FuncSig::MULTI_RET, ListOnlyFunc);
    sigs["getAsTable"] = FuncSig::MultiRetSig("getAsTable", "@CI,@VI", "@LO",FuncSig::NO_FLAGS,ListOnlyFunc);
    sigs["upgroup"] = FuncSig::MultiRetSig("upgroup", "@EI,@iI", "@LO", FuncSig::NO_FLAGS, ListOnlyFunc);
    sigs["omecleanup"]=FuncSig("omecleanup","","");
    //sigs["setvararray"]=FuncSig("setvararray","@AI,@SI","");
    
    //sdp
    sigs["SDPGetBooleanData"] = FuncSig("SDPGetBooleanData", "@SD,@SI,@SI", "@bO", FuncSig::NO_FLAGS, IntOnlyFunc);
    sigs["SDPGetCapabilities"]=FuncSig("@SD->GetCapabilities","","@LO");
    sigs["SDPGetCellSize"]=FuncSig("@SD->GetCellSize","","@sO");
    sigs["SDPGetColumnCount"]=FuncSig("@SD->GetColumnCount","","@sO");
    sigs["SDPGetExtents"] = FuncSig("SDPGetExtents", "@SD", "@iO", FuncSig::NO_FLAGS, ListOnlyFunc);
    sigs["SDPGetFielCol"] = FuncSig("GetFieldCol", "@SD,@TI", "@iO", FuncSig::NO_FLAGS, IntOnlyFunc);
    sigs["SDPGetDataMinMax"] = FuncSig("SDPGetDataMinMax", "@SD,@SI", "@LO", FuncSig::NO_FLAGS, ListOnlyFunc);
    sigs["SDPGetIntegerData"] = FuncSig("(int)SDPGetNumberData", "@SD,@SI,@SI", "@iO", FuncSig::NO_FLAGS, IntOnlyFunc);
    sigs["SDPGetNumberData"] = FuncSig("SDPGetNumberData", "@SD,@SI,@SI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["SDPGetRowCount"]=FuncSig("@SD->GetRowCount","","@iO");
	sigs["SDPGetNeighborCount"] = FuncSig("SDPGetNeighborCount", "@SD,@SI", "@bO", FuncSig::NO_FLAGS, SclrOnlyFunc);
	sigs["SDPGetNeighborForDirection"] = FuncSig("SDPGetNeighborForDirection", "@SD,@SI,@SI", "@bO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["SDPGetStringData"] = FuncSig("SDPGetStringData", "@SD,@SI,@SI,BI", "@cO", FuncSig::NO_FLAGS, StrOnlyFunc);
	sigs["SDPHasNeighborForDirection"] = FuncSig("SDPHasNeighborForDirection", "@SD,@SI,,@SI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["SDPNextTo"] = FuncSig("SDPNextTo", "@SD,@SI,@TI", "@bO", FuncSig::NO_FLAGS, IntOnlyFunc);
    sigs["SDPNextToArea"] = FuncSig("SDPNextToArea", "@SD,@SI,@TI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
    sigs["SDPNextToIDs"] = FuncSig::CustomFuncSig("SDPNextToID", GenSDPNextToID, FuncSig::NO_FLAGS, ListOnlyFunc);
    sigs["SDPNextToValues"] = FuncSig::CrossAggFuncSig("SDPNextToValues", "@SD,@TI,@SI", "@LO", FuncSig::NO_FLAGS, ListOnlyFunc);
    sigs["SDPSetData"] = FuncSig("SDPSetData", "@SD,@SI,@SI,@SI", "");
    sigs["SDPWithin"] = FuncSig("SDPWithin", "@SD,@SI,@TI,@SI", "@bO", FuncSig::NO_FLAGS, IntOnlyFunc);
    sigs["SDPWithinArea"] = FuncSig("SDPWithinArea", "@SD,@SI,@TI,@SI", "@sO", FuncSig::NO_FLAGS, SclrOnlyFunc);
}

void OMECFuncs::LoadAccumPatterns(std::map<STLString, std::pair<STLString, STLString> > & patterns)
{
    //accumulator funcs
    /*
     //accumulator arg codes
     
     @ai	- primary accumulation variable (integer).
     @as	- primary accumulation variable (scalar).
     @al	- primary accumulation variable (temp list).
     @bs	- secondary accumulation variable (scalar).
     @vs	- value statement (function argument).
     @ii	- loop increment variable.
     @li	- loop increment limit.
     @la - initialization statement for @al.
     
     */
    patterns["all"] = { "@ai=1;", "@ai=@ai && @vs;" };
    patterns["any"] = { "@ai=0;", "@ai=@ai || @vs;" };
    patterns["firsttrue"] = { "@ai=0;", "if(!@ai && @vs) @ai=@ii+1;" };
    patterns["greatest"] = { "@as=OME_SCALAR_MIN;", "if(@as < @vs) @as=@vs;" };
    patterns["howmanytrue"] = { "@ai=0;", "if(@vs) ++@ai;" };
    patterns["least"] = { "@as=OME_SCALAR_MAX;", "if(@as > @vs) @as=@vs;" };
    patterns["posgreatest"] = { "@ai=0;\nOME_SCALAR @bs=OME_SCALAR_MIN;", "if(@bs < @vs) { @ai=@ii+1; @bs=@vs;}" };
    patterns["posleast"] = { "@ai=0;\nOME_SCALAR @bs=OME_SCALAR_MAX;", "if(@bs > @vs) { @ai=@ii+1; @bs=@vs;}" };
    patterns["product"] = { "@as=@li.GetSize() ? 1.0 : 0.0;", "@as*=@vs;" };
    patterns["subtotals"] = { "@la", "@al[@ii]=@vs; if(@ii) @al[@ii]+=@al[@ii-1];" };
    patterns["sum"] = {"@as= 0.0;", "@as+=@vs;" };
}

void OMECFuncs::LoadConstants(std::map<STLString, STLString> & maps)
{
	maps["SDP_NORTH"] = "GD_N";
	maps["SDP_EAST" ] = "GD_E";
	maps["SDP_SOUTH"] = "GD_S";
	maps["SDP_WEST" ] = "GD_W";

	maps["SDP_NORTHEAST"] = "GD_NE";
	maps["SDP_SOUTHEAST"] = "GD_NE";
	maps["SDP_SOUTHWEST"] = "GD_SW";
	maps["SDP_NORTHWEST"] = "GD_NW";
}