#pragma once

#include "OMEDefines.h"
#include "RecordMgr.h"

class Model;
class OMEParser;

#ifndef OME_VARCHTYPE
#define OME_VARCHTYPE std::vector<OME_SCALAR>
//only define the following if contents can be garuanteed to be tightly packed
//#define OME_VARCHCONTIG
#endif

/** Container for all current model simulation values. The ValueArchive is responsible
for keeping multiple values for the same model component tightly packed together.*/
class __EXPORT__ ValueArchive
{
	friend class RecordMgr;
	///@cond DOX_NO_DOC
	struct MSetCompare;
	///@endcond
public:
	///@cond DOX_NO_DOC
    struct EntryInfo;

	typedef std::set < Model*, MSetCompare> ModelSet;
	typedef OME_VARCHTYPE::iterator	iterator;
	typedef void(*SVUpdateFunc)(void*);
	typedef std::list<EntryInfo> IDValList;
	///@endcond

	/** Flags indicating which type of submodels to include.*/
	enum MODELPARSE {	STATIC,		///< Only include static submodels.
						DYNAMIC,	///< Only include dynamic submodels.
						ALL			///< Include both static and dynamic models.
					};

	ValueArchive(const OME_SCALAR & startTime = 0.0,const OME_SCALAR & reportInterval = 1.0, const STLString & recordDir = STLString());
	ValueArchive(Model* root, const OME_SCALAR & startTime, const OME_SCALAR & reportInterval, const MODELPARSE & mode = ALL, const bool & mdlOnly = false, const STLString & recordDir = STLString());
	ValueArchive(const ValueArchive & archive);
	~ValueArchive();

	void ValueArchive::ClearAll();

	void AllocSpaceForRegisteredModels();
	void AllocSpaceForModel(Model* root, const MODELPARSE & mode = ALL);

	/** Index operator.
		@param i index of value to retrieve.
		@return reference to value at index i.
	*/
	inline OME_SCALAR& operator[](const size_t & i) 
	{
		//if the associated field is inactive, it should already be set to 0
		return m_values[i];
	};
	/** Const index operator.
		@param i index of value to retrieve.
		@return value at index i.
	*/
	inline OME_SCALAR operator[](const size_t & i) const { return m_values[i]; };

	/** Retrieve iterator starting at a specific slot.
		@param i The slot to start the iterator at.
		@return An iterator pointing at the value at index i.
	*/
	inline iterator GetIteratorForSlot(const size_t & i) { return m_values.begin() + i; }
	bool AddSpaceForEvaluable(Evaluable* pEval, size_t numCopies);
	void AddSpaceForModel(Model* pMdl, const size_t & numCopies);

	size_t InsertEvaluable(Evaluable* pEval);
	bool ResizeMultiValSlot(Evaluable* pEval, const size_t & oldSize);

	size_t GetSlotCount() const;

	bool IndexForID(const STLString & id, size_t & out) const;
	void SetSVUpdateFunc(SVUpdateFunc func, void* extra);
	//record stuff.
	OME_SCALAR GetFirstValue(const size_t & i);
	OME_SCALAR GetPreviousValue(const size_t & i);
	OME_SCALAR GetValueForTime(const size_t & i, const OME_SCALAR & time);

	void LoadRecordsForTime(const OME_SCALAR & time);
	void CacheRecordForTime(const OME_SCALAR & time);

	/** Set Records to be saved or discarded after simulation conclusion.
		@param retain If true retain records after run; otherwise records are discarded when done.
	*/
	inline void SetRetainRecords(const bool & retain) { m_retainRecords = retain;};
	void RefreshInds();
	void ReassignMdlPtrs();

	void SetModelInstanceActive(Model* pMdl, const size_t & inst, const bool & active);

	/** Have associated RecordMgr record the present state.
		@param timeStamp The time to associate with the recorded state.
	*/
	inline void RecordState(const OME_SCALAR & timeStamp) { if(m_values.size()) m_records.RecordState(timeStamp,this); };
	/** Have associated RecordMgr record the present state, forcing a full record recording.
		@param timeStamp The time to associate with the recorded state.
	*/
	inline void RecordFullState(const OME_SCALAR & timeStamp) { if (m_values.size()) m_records.RecordFullState(timeStamp, this); }
	/** Tell the associated RecordMgr to use minimum record keeping.
		@param minRec If true, use minimum record keeping. Otherwise, use normal record keeping.
	*/
	void UseMinRecord(const bool & minRec) {m_records.SetMinMode(minRec);}
	bool AddToMinTracking(Evaluable* pSrc);
	//debug
	STLString DumpInds();

	void GetIDValPairs(IDValList & out) const;

	RecordMgr::FullValueMap GetAllRecordedValues();
	void GetAllRecordedValues(RecordMgr::FullValueMap & fvm);
	OMESclrArray GetAllRecordedTimes();

	/** Info for a specific ValueArchive entry.*/
	struct EntryInfo
	{
		STLString id;			///< Unique Id of object associated with index.
		STLString name;			///< Name of object associatd with index.
		size_t ind;				///< Value archive index associated with entry.
		OME_SCALAR val;			///< Recorded value associated with entry.
		bool isAutoGen;			///< Source value is mapped to autogenerated variable.

		EntryInfo()
			:EntryInfo(STLString(), STLString(), 0, 0.0) {}
		/** Detailed destructor.
			@param inId Id of object.
			@param n Name of object.
			@param i index of object.
			@param v Value of object.
			@param autogen Flag indicating if the object was automatically generated.
		*/
		EntryInfo(const STLString & inId, const STLString & n, const size_t & i, const OME_SCALAR & v,const bool & autogen=false)
			:id(inId), name(n), ind(i), val(v),isAutoGen(autogen) {}
		/** Copy constructor.
			@param ei The entry to copy.
		*/
		EntryInfo(const EntryInfo & ei)
			:EntryInfo(ei.id, ei.name, ei.ind, ei.val,ei.isAutoGen){}
	};
 private:
	 
	 /**Comperator struct. */
	 struct MSetCompare
	 {
		 bool operator()(Model* lhs, Model* rhs);
	 };

	 /** Node for offsetMap.*/
	struct MapRefNode
	{
		
		size_t m_ind;		///< Index into ValueArchive for first value.
		Evaluable* m_pSrc;	///< Pointer to Source Object.

		/** Default Constructor.
			@param src Pointer to source Evaluable object.
			@param ind Index of first value in for src in ValueArchive.
		*/
		MapRefNode(Evaluable* src=NULL, const size_t & ind=0)
			:m_ind(ind), m_pSrc(src) {}
		/** Copy Constructor.
			@param mrn The MapRefNode to copy.
		*/
		MapRefNode(const MapRefNode & mrn)
			:m_ind(mrn.m_ind), m_pSrc(mrn.m_pSrc){}

		/** Less-than operator.
			@param rhs The MapRefNode to compare against.
			@return true if m_ind is less than rhs.m_ind; false otherwise.
		*/
		bool operator<(const MapRefNode & rhs) const
		{
			return m_ind < rhs.m_ind;
		}
	};
	
	/** Abbreviated reference to the archive space encompassed by a given submodel.*/
	struct ModelSummary
	{
		Model* pRefModel;   ///< Pointer to the represented model.
		STLString srcKey;	///< Key/ID of the object within the model that starts the block of values.
		size_t instanceLength;   ///<The total number of slots occupied by a single model instance;

		ModelSummary()
			:pRefModel(NULL), instanceLength(0) {}

		bool operator<(const ModelSummary & rhs) const
		{
			return srcKey < rhs.srcKey;
		}
	};

	void AddEvaluable(Evaluable* pEval, const MODELPARSE & mode);  
	void RegisterModelTree(Model* root, const MODELPARSE & mode);

	OME_VARCHTYPE m_values;					///< Container for storing all values.
	std::map<STLString, MapRefNode> m_offsetMap;	///< ID - ind map for all value offsets.
	std::map<Model*,ModelSummary> m_modelMap;					///< Map of all included parent models and their domains.
	RecordMgr  m_records;					///< Stores records of values for each time step throughout simulation run.
	bool m_retainRecords;					///< If true, retainRecords after Simulation run.
	bool m_spaceAllocated;					///< If true, the minimum amount of needed space has been allocated.
	SVUpdateFunc SVFunc;					///< Function for updating state variables.
	void* m_SVFExtra;						///< Pointer to extra data to pass in to invocations of SVFunc.

	/** Provide a string token for the record model parse mode.
		@param md The mode to tokenize.
		@return string with representation of model parse mode.
	*/
	inline STLString ModeToStr(const MODELPARSE & md)
	{
		STLString ret;
		switch (md)
		{
		case STATIC:
			ret= STLString("Static");
			break;
		case DYNAMIC:
			ret = STLString("Dynamic");
			break;
		case ALL:
			ret = STLString("All");
			break;
		}
		return ret;
	}
};

