#pragma once
#include <string.h>
#include "../OMEDefines.h"
#include "XMLLoadable.h"
#include "../events/Eventable.h"
#include "Summarizable.h"
#include "OMEEventTypes.h"
#include "DebugOutput.h"
#include "OMETypes.h"
#include "ModelEnum.h"
//additional utils


class Model;


/** Base Class for model objects.
	Base class for all entities that are a part of the model itself, or act as intermediates during model construction

*/
class __EXPORT__ OMEObject : public XMLLoadable, public Eventable, public Summarizable 
{
public:
   /**	Default Constructor.
		Sets numeric values to -1.
   */
	OMEObject() : m_name(STLString()),
		m_pParentModel(NULL), m_evalPriority(0), m_initPriority(0), m_isInternal(false), m_isAutoGenerated(false) {}
   
   /**	Basic Constructor.
			@param n  id of new object.
   */
   OMEObject(STLString n) : m_id(n),m_name(n),
	   m_pParentModel(NULL), m_evalPriority(0), m_initPriority(0), m_isInternal(false), m_isAutoGenerated(false) { }

	/** Basic Constructor.
		@param id The unique identifier for the new object.
		@param n The name of the new object.
	*/
   OMEObject(STLString id, STLString n) : m_id(id), m_name(n),
	   m_pParentModel(NULL), m_evalPriority(0), m_initPriority(0), m_isInternal(false), m_isAutoGenerated(false) { }

   /**	XML Constructor.
		This constructor instantiates the object based on the arguments passed in.
			@param pTie  the current Tiny XML Element
			@param tag   the name of the desired tag containing the info.
			@param filename  the filename associated with the XML info.
			@see	GetXMLForObject()
   */
   OMEObject(TI2Element* pTie,STLString & tag, STLString & filename)
	   :m_evalPriority(0), m_initPriority(0), m_isInternal(false), m_isAutoGenerated(false)
	{ PopulateFromXML(pTie,tag,filename); }


   /** Copy Constructor.
		@param obj the object to copy
	*/
   OMEObject(const OMEObject & obj) { Duplicate(obj); }
   /** Assignment Operator.
		@param obj The object to use in the assignment.
	*/
	OMEObject& operator=(const OMEObject & obj) { Duplicate(obj); return *this;};

	bool operator==(const OMEObject & obj);
   /**	Destructor
	*/
	virtual ~OMEObject( ) { /*cout<<"OBJ!!"<<endl;*/}

   /** @return Read-only reference to the object's name. */
	inline const STLString& GetName() const { return m_name; };

   /** @param name The new name for the object.*/
   virtual void SetName(const STLString & name) { m_name=name;};
   /** @param name The new name for the object as a raw C-String.*/
   virtual void SetName(const OMEChar* name) { SetName(STLString(name)); };

   public:
	

	/** Determines if object is a root element.
		Returns a root element based on the presence or absence of m_parentModel pointer.
		@return true if object has no parent, false otherwise
	*/
   bool isRoot() { return m_pParentModel ? false : true; }

	/** Unique OMEObject class identifier */
   virtual OMETYPE GetOMEType( void ) const=0;// { return OME_BASE; }
	/** Check to see if object is an instance of or inherits from object of type.
		@param type The type to search for.
		@return true if class or parent classes match type; otherwise returns false.
	*/
	virtual bool IsOMEType(OMETYPE type) const { return type==OME_BASE ? true : false; }

   virtual STLString GetXMLRepresentation(const unsigned int indent=0,const unsigned int inc=4);
	

   virtual void GetXMLAttributes(StrArray & out) const;
   virtual void GetXMLSubNodes(StrArray & out,const unsigned int indent=0,const unsigned int inc=4);
   virtual const OMEChar* GetXMLTag() const { return "omeobject"; }

   virtual unsigned int Prioritize(unsigned int currPriority, const bool isInitial=false);
   virtual void EventAction(const CentralEvent & ev, void* extra);

   virtual const OMEChar* ToString(const OMEChar tabChar=' ', const unsigned int indent=0, const unsigned int inc=4) const;

   /** Create a copy of the target object.
		@return a pointer to a new copy of this object.
   */
   virtual OMEObject* Clone()=0;

   /** Static comparator that can be used for sorting OMEObjects by priority.
		@param lhs Pointer to the first object to compare.
		@param rhs Pointer to the second object to compare.
		@return true if the lhs priority is greater than the rhs priority.
   */
   static bool CompareEvalPriority(const OMEObject* lhs, const OMEObject* rhs) { return lhs->m_evalPriority > rhs->m_evalPriority; }
	/** Static comparator that can be used for sorting OMEObjects by initialization priority.
		@param lhs Pointer to the first object to compare.
		@param rhs Pointer to the second object to compare.
		@return true if the lhs priority is greater than the rhs priority.
   */
   static bool CompareInitPriority(const OMEObject* lhs, const OMEObject* rhs) { return lhs->m_initPriority > rhs->m_initPriority; }

	/** @param pMdl Pointer to model to assign as parent to object. */
	virtual void SetParentModel(Model* pMdl) { m_pParentModel=pMdl; }
	/** @return Pointer to parent BaseModel object. */
	virtual Model* GetParentModel() const {return m_pParentModel; }

	/** @return Unique id of object.*/
	inline STLString GetID() const { return m_id; }

	/** @param id The new unique id of the object. */
	inline void SetID(const STLString & id) { m_id=id; }
	/** @param id The new unique id of the object as a raw C-string. */
	inline void SetID(const OMEChar* id) { m_id = STLString(id); }
	/** @return The evaluation priority of the object. */
	virtual unsigned int GetEvalPriority() const { return m_evalPriority; }
	/** @param ep The new evaluation priority for the object. */
	inline void SetEvalPriority(const unsigned int ep) { m_evalPriority=ep; }
	/** @return The initialization priority for the object.*/
	virtual unsigned int GetInitPriority() const { return m_initPriority; }
	/** @param ip The new priority for initialization. */
	inline void SetInitPriority(const unsigned int ip) { m_initPriority=ip; }
	/** @return true if object is internal to the model heirarchy (is not exposed to any external reporting mechanisms); false otherwise. */
	inline bool GetInternal() const { return m_isInternal; }
	/** @param ii Value that determines whether or not the object is internal to the model heirarchy.*/
	inline void SetInternal(const bool & ii) { m_isInternal=ii; }

	/** @return true if object is internal to the model heirarchy (is not exposed to any external reporting mechanisms); false otherwise. */
	inline bool GetAutoGenerated() const { return m_isAutoGenerated; }
	/** @param iag Value that determines whether or not the object is internal to the model heirarchy.*/
	inline void SetAutoGenerated(const bool & iag) { m_isAutoGenerated=iag; }

	const OMEChar* LabelForType() const;
	const OMEChar* StrForType() const;
	static const OMEChar* LabelForType(OMETYPE type);
	static const OMEChar* StrForType(OMETYPE type);

	/** @return name of OMEObject formatted for use in expression. */
	inline STLString GetExprName() const { return ScrubName(m_name); }
	
	STLString GetFullMdlPathName() const;
protected:
	STLString m_id;				/**< unique id of object; used for lookup tables */   
	unsigned int m_evalPriority; ///< Update event priority.
   unsigned int m_initPriority; ///< Initialization priority.

   bool m_isInternal;			///< if true, object will not be returned as a readable field to outside queries.
   bool m_isAutoGenerated;		///< if true, object will only exist for logic update and will not be saved or reported.

   Model* m_pParentModel;		/**< parent model of object */
	STLString m_name;				/**< visible name of object; */
	STLString GetXMLForObject(const unsigned int indent,const unsigned int inc);
	
	void Duplicate(const OMEObject & obj);

	virtual void GetXMLAttributeMap(XMLAttrVector & out);
	virtual int PopulateFromComplexElements(TI2Element* pCurrElem,const STLString & tag, const STLString & filename);

private:

};
