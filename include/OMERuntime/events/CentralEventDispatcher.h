#pragma once
#include "CentralEvent.h"
#include "Eventable.h"
#include "ErrCollection.h"
#include <list>
#include <map>
#include <queue>
#include <mutex>

///	@name Predefined CentralEventDispatcher Event Types.
///@{
const std::string CED_END = "CED_TERM";			///< Event Designating the Dispatcher is shutting down.
const std::string CED_INCREMENT = "CED_INC";	///< Event indicating that the Dispatcher is about to increment its time step.
const std::string CED_INIT = "CED_INI";			///< Event to signify initialization period.
const std::string CED_DUMP = "CED_DUMP";		///< Event that tells the Dispatcher to dump the contents of its queue to the console.
const std::string CED_ERR = "CED_ERR";			///< Event representing the occurrance of an error that may disrupt normal operations.
const std::string CED_PAUSE = "CED_PAUSE";		///< Event causing the Event system to halt and return, preserving state.
///@}

/// Wrapper for eventable objects entered as listeners.
struct EventListener
{
	Eventable* listener;	///< Eventable object that is listening for a given event.
	bool noClear;			///< Makes listener permanent unless explicitly removed.
	void* extra;			///< Arbitrary data to be passed in when the listener is called

	EventListener() : listener(NULL),extra(NULL),noClear(false) {}

    /**Comparison operrator
      @param rhs The EventListener to compare to.
      @return true if listener and extra fields are equal; false otherwise.
    */
	bool operator==(const EventListener & rhs) const
	{ return (listener == rhs.listener) && (extra == rhs.extra) && (noClear==rhs.noClear); }
};


typedef std::priority_queue<CentralEvent> EventQueue;
typedef std::list<EventListener> ListenerList;
typedef std::map<std::string,ListenerList> ListenerMap;

/** Class that manages an event queue for a centralized event driven environment. */
class CentralEventDispatcher : public Eventable
{
public:

   /** @enum RUN_CODE
	Enum for loop termination flags 
   */
   enum RUN_CODE
   {
      CEDR_NA = 0,      ///< No termination flag set.
      CEDR_COMPLETE,    ///< Dispatcher completed run successfully.
      CEDR_ERROR,       ///< Dispatcher terminated due to error.
      CEDR_PAUSE        ///< Dispatcher exited on paused; will pick up where it left of the next time it is run.
   };

	CentralEventDispatcher(void);
	~CentralEventDispatcher(void);

	void RegisterEventListener(const std::string eventType, Eventable* obj,void* extra=NULL,bool permanent=false);
	void RemoveListener(const std::string eventType, Eventable* obj);

	void PostEvent(const CentralEvent & ev);
	void DispatchEvent(CentralEvent & ev);
	void FlushEvents();
	void ClearEvents();
	void ClearListeners();

	RUN_CODE RunDispatcher(OME_SCALAR timeStart, OME_SCALAR timeEnd, OME_SCALAR interval);

	virtual void EventAction(const CentralEvent & ev, void* extra);

	/** Register an ErrCollection to report errors to.
		@param pErr The ErrCollection to report to.
	*/
	void RegisterErrCollection(ErrCollection* pErr) { m_pErrs=pErr;}

	/** @return Interval between time steps. */
	OME_SCALAR GetTimeInterval() {return m_timeInterval;}
	/** @return Current time step. */
	OME_SCALAR GetPresentTime() {return m_currentTime;}

   /** @return The last RUN_CODE generated by the event loop. */
   inline RUN_CODE GetLastRunCode() const { return m_lastCode; }

   void BroadcastAnyErrors();

	//debug
	void DumpQueueToConsole();
	const OMEChar* DumpQueue();
	//singleton
	/** Singleton / uniform instance of the CentralEventDispatcher. */
	static CentralEventDispatcher& GetSingletion();

private:
	EventQueue m_events;			///< Priority queue used to store and dispatch events.
	ListenerMap m_listeners;		///< Map of listing Eventable objects, keyed by event type identifiers.
	bool m_isRunning;				///< Flag that denotes that the Dispatcher is running through its queue if true.
	OME_SCALAR m_currentTime;			///< The current time step.
	OME_SCALAR m_timeStart;				///< Time step at which the Event Dispatcher begins running.
	OME_SCALAR m_timeEnd;				///< Time step at which the Event Dispatcher finishes running.
	OME_SCALAR m_timeInterval;			///< Increment value between time steps.
	OME_SCALAR m_khErr;					///< Correction for Kahan algorithm http://en.wikipedia.org/wiki/Kahan_summation_algorithm
	size_t m_timeTicks;				///< Integer count of timesteps that have passed so far.
   RUN_CODE m_lastCode;				///< The last code reported by the Event Dispatcher on exit of the dispatch loop.

   ErrCollection* m_pErrs;			///< Pointer to error collection to report errors to.

    std::recursive_mutex m_queueLock;			///< Mutex for locking event queue access.

	void BroadcastEvent(const CentralEvent & ev);
	

};

//singletons
#define EVENT_DISPATCHER	CentralEventDispatcher::GetSingletion()
#define POST_EVENT( x )		CentralEventDispatcher::GetSingletion().PostEvent(x)